"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[966],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>h});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var u=r.createContext({}),l=function(n){var e=r.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=l(n.components);return r.createElement(u.Provider,{value:e},n.children)},p="mdxType",g={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,u=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),p=l(t),m=a,h=p["".concat(u,".").concat(m)]||p[m]||g[m]||i;return t?r.createElement(h,o(o({ref:e},c),{},{components:t})):r.createElement(h,o({ref:e},c))}));function h(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=n,s[p]="string"==typeof n?n:a,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6359:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const i={},o="Concurrency",s={unversionedId:"Golang/Concurrency",id:"Golang/Concurrency",title:"Concurrency",description:"Introduction",source:"@site/docs/Golang/Concurrency.md",sourceDirName:"Golang",slug:"/Golang/Concurrency",permalink:"/docs/Golang/Concurrency",draft:!1,editUrl:"https://github.com/fsiggor/fsiggor.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/Golang/Concurrency.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GPG Keys",permalink:"/docs/CLI/GPG Keys"},next:{title:"Debugging",permalink:"/docs/Golang/Debugging"}},u={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Goroutines and channels",id:"goroutines-and-channels",level:2},{value:"Waitgroups",id:"waitgroups",level:2},{value:"Mutex",id:"mutex",level:2},{value:"Worker",id:"worker",level:2}],c={toc:l},p="wrapper";function g(n){let{components:e,...t}=n;return(0,a.kt)(p,(0,r.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"concurrency"},"Concurrency"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"It is the ability to execute multiple tasks or processes simultaneously, that allows efficient use of system resources and improves application performance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Note that concurrency and parallelism are two different terms. Concurrency it\u2019s meant to do `multiple tasks` at the `same time`. It is a term used for writing programs. Parallelism it\u2019s meant to do `multiple tasks` with `multiple resources` at `the same time` . It is hardware related term, used when building CPUs and cores.\n")),(0,a.kt)("h2",{id:"goroutines-and-channels"},"Goroutines and channels"),(0,a.kt)("p",null,"Goroutines and channels are mainly used for achieving concurrency in Golang:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Goroutines:"),"  can be thought of as functions that run independently in the background, allowing the program to perform multiple tasks simultaneously."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Channels:")," are an essential part of concurrency in Go, allowing Goroutines to communicate with each other and share data.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main  \n  \nimport (  \n "fmt"  \n "strings"  \n)  \n  \nfunc analyzeSentiment(data string, resultChan chan string) {  \n // Perform sentiment analysis on the input data  \n // Here, we simply check if the input contains the word "happy"  \n if strings.Contains(strings.ToLower(data), "happy") {  \n  resultChan <- "positive"  \n } else {  \n  resultChan <- "negative"  \n }  \n}  \n  \nfunc main() {  \n // Define the input data  \n input := []string{  \n  "I am so happy today!",  \n  "I hate this weather.",  \n  "Happy birthday!!",  \n }  \n  \n // Create a channel for the sentiment analysis results  \n resultChan := make(chan string)  \n  \n // Launch a goroutine to analyze the sentiment of each input string  \n for _, data := range input {  \n  go analyzeSentiment(data, resultChan)  \n }  \n  \n // Wait for the results to be processed and print them  \n for i := 0; i < len(input); i++ {  \n  fmt.Println(<-resultChan)  \n }  \n}\n')),(0,a.kt)("h2",{id:"waitgroups"},"Waitgroups"),(0,a.kt)("p",null,"Waitgroups provide a way to synchronize the execution of Goroutines and ensure that all Goroutines have been completed before terminating."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main  \n  \nimport (  \n "fmt"  \n "strings"  \n "sync"  \n)  \n  \nvar wg sync.WaitGroup // Initialize waitgroup  \n  \nfunc analyzeSentiment(data string, resultChan chan string) {  \n // Signal that the goroutine has completed its work  \n defer wg.Done()  \n  \n if strings.Contains(strings.ToLower(data), "happy") {  \n  resultChan <- "positive"  \n } else {  \n  resultChan <- "negative"  \n }  \n}  \n  \nfunc main() {  \n input := []string{  \n  "I am so happy today!",  \n  "I hate this weather.",  \n  "Happy birthday!!",  \n }  \n  \n resultChan := make(chan string)  \n  \n for _, data := range input {  \n  // Add one to the waitgroup for each goroutine  \n  wg.Add(1)  \n  go analyzeSentiment(data, resultChan)  \n }  \n  \n go func() {  \n  // Wait for all goroutines to complete  \n  wg.Wait()  \n  // Close the result channel to signal the workers to terminate  \n  close(resultChan)  \n }()  \n  \n // Print the results  \n for i := 0; i < len(input); i++ {  \n  fmt.Println(<-resultChan)  \n }  \n}\n')),(0,a.kt)("h2",{id:"mutex"},"Mutex"),(0,a.kt)("p",null,"Mutex(mutual exclusion) working on a locking mechanism. When a resource is acquired by one process, add a lock, and after finishing it, unlock it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main  \n  \nimport (  \n "fmt"  \n "strings"  \n "sync"  \n)  \n  \n// Create a mutex to synchronize access to the counter variable  \nvar mu sync.Mutex  \nvar wg sync.WaitGroup  \n  \nfunc analyzeSentiment(data string, resultChan chan string, counter *int) {  \n  \n defer wg.Done()  \n  \n if strings.Contains(strings.ToLower(data), "happy") {  \n  // Acquire the lock before accessing the shared counter variable  \n  mu.Lock()  \n  *counter++  \n  mu.Unlock()  \n  resultChan <- "positive"  \n } else {  \n  resultChan <- "negative"  \n }  \n}  \n  \nfunc main() {  \n input := []string{  \n  "I am so happy today!",  \n  "I hate this weather.",  \n  "Happy birthday!!",  \n }  \n  \n resultChan := make(chan string)  \n  \n // Create a counter variable to track the number of positive sentiments  \n counter := 0  \n  \n for _, data := range input {  \n  wg.Add(1)  \n  go analyzeSentiment(data, resultChan, &counter)  \n }  \n  \n go func() {  \n  wg.Wait()  \n  close(resultChan)  \n }()  \n  \n // Print the results  \n for i := 0; i < len(input); i++ {  \n  fmt.Println(<-resultChan)  \n }  \n  \n // Print the number of positive sentiments  \n fmt.Printf("%d out of %d input strings had a positive sentiment.\\n", counter, len(input))  \n}\n')),(0,a.kt)("h2",{id:"worker"},"Worker"),(0,a.kt)("p",null,"A worker is a goroutine that performs a specific task or set of tasks in the background, independently of the main program or other workers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main  \n  \nimport (  \n "bufio"  \n "fmt"  \n "os"  \n "strings"  \n "sync"  \n)  \n  \nvar mu sync.Mutex  \nvar wg sync.WaitGroup  \n  \nfunc analyzeSentiment(data string, resultChan chan<- string) {  \n if strings.Contains(strings.ToLower(data), "happy"){  \n  resultChan <- "positive"  \n } else {  \n  resultChan <- "negative"  \n }  \n}  \n  \nfunc worker(inputChan <-chan string, resultChan chan<- string, k int) {  \n  \n defer wg.Done()  \n  \n for data := range inputChan {  \n  analyzeSentiment(data, resultChan)  \n  \n  // Acquire the lock to access worker  \n  mu.Lock()  \n  fmt.Printf("Worker %d processed line: %s\\n", k, data)  \n  mu.Unlock()  \n }  \n  \n}  \n  \nfunc main() {  \n inputChan := make(chan string, 10)  \n resultChan := make(chan string, 10)  \n  \n // Launch two worker goroutines to process the sentiment analysis results  \n for i := 0; i < 2; i++ {  \n  wg.Add(1)  \n  go worker(inputChan, resultChan, i)  \n }  \n  \n // Read lines from stdin and send them to the workers  \n scanner := bufio.NewScanner(os.Stdin)  \n for scanner.Scan() {  \n  line := scanner.Text()  \n  inputChan <- line  \n }  \n close(inputChan)  \n  \n go func() {  \n  wg.Wait()  \n  close(resultChan)  \n }()  \n  \n numPositive := 0  \n numNegative := 0  \n for result := range resultChan {  \n  switch result {  \n  case "positive":  \n   numPositive++  \n  case "negative":  \n   numNegative++  \n  }  \n }  \n  \n // Print the results  \n fmt.Printf("Positive: %d\\n", numPositive)  \n fmt.Printf("Negative: %d\\n", numNegative)  \n}\n')),(0,a.kt)("p",null,"References:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://blog.canopas.com/a-practical-guide-to-concurrency-in-golang-key-terms-and-examples-aa54dddb9fec"},"A Practical Guide to Concurrency in Golang"))))}g.isMDXComponent=!0}}]);