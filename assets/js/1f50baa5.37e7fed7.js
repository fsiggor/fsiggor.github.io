"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[886],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},s="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),s=p(n),m=r,d=s["".concat(c,".").concat(m)]||s[m]||f[m]||o;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[s]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4649:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="Reflection in Go",l={unversionedId:"Golang/Reflection",id:"Golang/Reflection",title:"Reflection in Go",description:"Reflection in Go allows you to examine and manipulate variables and types while your program is running. This means that you can check the type of a variable, change its value, or even call its methods.",source:"@site/docs/Golang/Reflection.md",sourceDirName:"Golang",slug:"/Golang/Reflection",permalink:"/docs/Golang/Reflection",draft:!1,editUrl:"https://github.com/fsiggor/fsiggor.github.io/tree/main/packages/create-docusaurus/templates/shared/docs/Golang/Reflection.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pointers",permalink:"/docs/Golang/Pointers"},next:{title:"Logging Best Practices",permalink:"/docs/Logging"}},c={},p=[{value:"<code>reflect.Value</code>",id:"reflectvalue",level:3},{value:"<code>reflect.Type</code>",id:"reflecttype",level:3},{value:"<strong>Common Usages</strong>",id:"common-usages",level:3}],u={toc:p},s="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(s,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"reflection-in-go"},"Reflection in Go"),(0,r.kt)("p",null,"Reflection in Go allows you to examine and manipulate variables and types while your program is running. This means that you can check the type of a variable, change its value, or even call its methods."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"reflect")," package has two main types, ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Type")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Value"),", which allow you to examine the type and value of a variable."),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.TypeOf()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.ValueOf()")," functions to obtain the type and value of any value, respectively."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main  \n  \nimport (  \n    "fmt"  \n    "reflect"  \n)  \n  \nfunc main() {  \n    num := 123  \n    numType := reflect.TypeOf(num)  \n    numValue := reflect.ValueOf(num)  \n    fmt.Println("Type:", numType)  \n    fmt.Println("Value:", numValue)  \n}  \n  \n// Type: int  \n// Value: 123\n')),(0,r.kt)("h3",{id:"reflectvalue"},(0,r.kt)("inlineCode",{parentName:"h3"},"reflect.Value")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Value")," type is one of the key types in the reflect package in Go. It acts as a wrapper around a value, allowing you to obtain information about it and perform operations on it."),(0,r.kt)("p",null,"For instance, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Kind()")," method to determine the type of value that x is (in this case, an int) or use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Int()")," method to get the integer value of x. Additionally, you can change the value of x using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Set()")," method"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nfunc main() {  \n    x := 10   \n    p := &x  \n    v := reflect.ValueOf(p)  // v is reflect.Value of pointer of x  \n  \n    fmt.Println("Kind of x:", v.Kind())  // "ptr"  \n  \n    v = v.Elem()  // now v is reflect.Value of x (not pointer anymore)  \n  \n    fmt.Println("Kind of x:", v.Kind())  // "int"  \n  \n    fmt.Println("Value of x:", v.Int())  // 10  \n  \n    v.SetInt(20)    \n    fmt.Println("Value of x after change:", x)  // 20  \n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Important"),": note that a ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Value")," holds a value, not the variable itself. If the value is a pointer to a struct, the ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Value")," will hold the pointer, not the value that the pointer points to."),(0,r.kt)("h3",{id:"reflecttype"},(0,r.kt)("inlineCode",{parentName:"h3"},"reflect.Type")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect.Type")," in Go is like a comprehensive guide to types, providing all the necessary information about a type, such as its name and composition. It acts as a template, providing all the information you need to know about the type."),(0,r.kt)("p",null,"You can use it to find information about a type, like its name, or to determine the type of a variable, such as struct, slice or pointer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\ntype Car struct {  \n    Model string  \n    Year int  \n    EngineSize float64  \n}  \n  \nfunc main() {  \n    var car Car  \n    t := reflect.TypeOf(car)  \n  \n    fmt.Println("Name:", t.Name()) // "Car"  \n  \n    fmt.Println("Kind:", t.Kind()) // "struct"  \n  \n    fmt.Println("Number of fields:", t.NumField()) // 3  \n  \n    // iterate all fields of Car struct  \n    for i := 0; i < t.NumField(); i++ {  \n        field := t.Field(i)  \n        fmt.Println("Field name:", field.Name)  \n        fmt.Println("Field type:", field.Type)  \n    }  \n}  \n  \n// Field name: Model  \n// Field type: string  \n// Field name: Year  \n// Field type: int  \n// Field name: EngineSize  \n// Field type: float64\n')),(0,r.kt)("h3",{id:"common-usages"},(0,r.kt)("strong",{parentName:"h3"},"Common Usages")),(0,r.kt)("p",null,"Reflection is a powerful feature in Go that can be used for various purposes, such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Custom struct tag:")," This technique allows you to add custom metadata to struct fields, which can be accessed and used at runtime. ",(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@func25/custom-struct-tag-technique-in-go-8667bf7da457"},"See")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dynamic type checking and type assertions:")," You can check the type of a variable at runtime and perform type assertions to ensure that a variable is of the expected type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Iterating over struct fields:")," You can use reflection to iterate over the fields of a struct, even if the struct type is unknown at compile time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Implementing dependency injection:")," Reflection can be used to implement dependency injection frameworks, by using the ",(0,r.kt)("inlineCode",{parentName:"li"},"ValueOf")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Set")," methods of the reflect package to set the fields of structs at runtime.")),(0,r.kt)("p",null,"And much more, reflection is used in many packages to create useful utilities."),(0,r.kt)("p",null,"Reference: ",(0,r.kt)("a",{parentName:"p",href:"https://levelup.gitconnected.com/reflection-in-go-everything-you-need-to-know-to-use-it-effectively-52c78da1f4ff"},"https://levelup.gitconnected.com/reflection-in-go-everything-you-need-to-know-to-use-it-effectively-52c78da1f4ff")))}f.isMDXComponent=!0}}]);